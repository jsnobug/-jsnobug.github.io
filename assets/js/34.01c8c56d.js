(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{384:function(t,a,s){"use strict";s.r(a);var e=s(25),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"前端性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端性能优化"}},[t._v("#")]),t._v(" 前端性能优化")]),t._v(" "),s("h2",{attrs:{id:"浏览器缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[t._v("#")]),t._v(" 浏览器缓存机制")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。")])]),t._v(" "),s("p",[t._v("浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下：")]),t._v(" "),s("ol",[s("li",[t._v("Memory Cache")]),t._v(" "),s("li",[t._v("Service Worker Cache")]),t._v(" "),s("li",[t._v("HTTP Cache")]),t._v(" "),s("li",[t._v("Push Cache")])]),t._v(" "),s("p",[t._v("HTTP 缓存是最主要、最具有代表性的缓存策略，也是每一位前端工程师都应该深刻理解掌握的性能优化知识点。")]),t._v(" "),s("h3",{attrs:{id:"http-缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存机制"}},[t._v("#")]),t._v(" HTTP 缓存机制")]),t._v(" "),s("p",[t._v("HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。它又分为"),s("strong",[t._v("强缓存")]),t._v("和"),s("strong",[t._v("协商缓存")]),t._v("。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。")]),t._v(" "),s("h4",{attrs:{id:"强缓存的特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存的特征"}},[t._v("#")]),t._v(" 强缓存的特征")]),t._v(" "),s("p",[t._v("强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，"),s("strong",[t._v("不会再与服务端发生通信。")])]),t._v(" "),s("p",[t._v("命中强缓存的情况下，返回的 HTTP 状态码为 200。from disk cache")]),t._v(" "),s("h4",{attrs:{id:"强缓存的实现：从-expires-到-cache-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存的实现：从-expires-到-cache-control"}},[t._v("#")]),t._v(" 强缓存的实现：从 expires 到 cache-control")])])}),[],!1,null,null,null);a.default=r.exports}}]);